# Database Backup Workflow - Elite DevOps Protocol
# Fixes: Socket connection errors, proper URL encoding, SSL enforcement
name: Database Backup

on:
  schedule:
    # Daily at 02:00 UTC
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      backup_type:
        description: 'Type of backup'
        required: true
        default: 'full'
        type: choice
        options:
          - full
          - schema-only
          - data-only
      environment:
        description: 'Target environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      upload_to_s3:
        description: 'Upload to S3'
        required: false
        default: true
        type: boolean

permissions:
  contents: read
  actions: write

env:
  BACKUP_RETENTION_DAYS: 30
  COMPRESSION_LEVEL: 9

jobs:
  database-backup:
    runs-on: ubuntu-latest
    name: Database Backup
    timeout-minutes: 30

    outputs:
      backup_file: ${{ steps.backup.outputs.backup_file }}
      backup_size: ${{ steps.backup.outputs.backup_size }}
      checksum: ${{ steps.backup.outputs.checksum }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # ================================================================
      # PRE-FLIGHT SECRET VALIDATION (Prevents socket errors)
      # ================================================================
      - name: Pre-flight Secret Validation
        id: validate
        run: |
          echo "Validating required secrets..."
          MISSING=""

          if [ -z "${{ secrets.SUPABASE_PROJECT_ID }}" ]; then
            MISSING="$MISSING SUPABASE_PROJECT_ID"
          fi

          if [ -z "${{ secrets.SUPABASE_DB_PASSWORD }}" ]; then
            MISSING="$MISSING SUPABASE_DB_PASSWORD"
          fi

          if [ -n "$MISSING" ]; then
            echo "::error::Missing required secrets:$MISSING"
            echo "::error::This causes socket connection errors. Configure secrets in repository settings."
            exit 1
          fi

          echo "secrets_valid=true" >> $GITHUB_OUTPUT
          echo "All required secrets configured"

      # ================================================================
      # INSTALL POSTGRESQL CLIENT
      # ================================================================
      - name: Setup PostgreSQL client
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq postgresql-client
          psql --version

      # ================================================================
      # CONSTRUCT DATABASE URL (With URL Encoding for Special Characters)
      # ================================================================
      - name: Construct Database URL
        id: db-url
        run: |
          # URL encode the password to handle special characters
          ENCODED_PASSWORD=$(python3 -c "import urllib.parse; print(urllib.parse.quote('${{ secrets.SUPABASE_DB_PASSWORD }}', safe=''))")

          # Construct proper connection string with SSL enforcement
          DB_URL="postgresql://postgres:${ENCODED_PASSWORD}@db.${{ secrets.SUPABASE_PROJECT_ID }}.supabase.co:5432/postgres?sslmode=require"

          # Store for later steps (masked in logs)
          echo "::add-mask::${ENCODED_PASSWORD}"
          echo "db_url=${DB_URL}" >> $GITHUB_OUTPUT

          echo "Database URL constructed successfully"

      # ================================================================
      # CONNECTION DIAGNOSTICS (Fail fast with clear error messages)
      # ================================================================
      - name: Test Database Connection
        id: connection-test
        run: |
          echo "Testing database connectivity..."

          # Test with timeout to fail fast on socket errors
          if timeout 30 psql "${{ steps.db-url.outputs.db_url }}" -c "SELECT 1 AS connection_test;" > /dev/null 2>&1; then
            echo "connection_success=true" >> $GITHUB_OUTPUT
            echo "Database connection successful"
          else
            echo "::error::Database connection failed"
            echo ""
            echo "=== Connection Diagnostics ==="
            echo "Host: db.${{ secrets.SUPABASE_PROJECT_ID }}.supabase.co"
            echo "Port: 5432"
            echo "SSL Mode: require"
            echo ""
            echo "Possible causes:"
            echo "  1. Invalid SUPABASE_PROJECT_ID"
            echo "  2. Invalid SUPABASE_DB_PASSWORD"
            echo "  3. Database is paused or unavailable"
            echo "  4. IP restrictions blocking GitHub Actions"
            exit 1
          fi

      # ================================================================
      # CREATE BACKUP (Schema + Data with compression)
      # ================================================================
      - name: Create Database Backup
        id: backup
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          BACKUP_TYPE="${{ github.event.inputs.backup_type || 'full' }}"
          ENV="${{ github.event.inputs.environment || 'production' }}"

          echo "Creating ${BACKUP_TYPE} backup..."

          case "$BACKUP_TYPE" in
            schema-only)
              BACKUP_FILE="backup-${ENV}-schema-${TIMESTAMP}.sql"
              pg_dump "${{ steps.db-url.outputs.db_url }}" \
                --schema-only \
                --no-owner \
                --no-privileges \
                -f "$BACKUP_FILE"
              ;;
            data-only)
              BACKUP_FILE="backup-${ENV}-data-${TIMESTAMP}.sql"
              pg_dump "${{ steps.db-url.outputs.db_url }}" \
                --data-only \
                --no-owner \
                --no-privileges \
                -f "$BACKUP_FILE"
              ;;
            full|*)
              BACKUP_FILE="backup-${ENV}-full-${TIMESTAMP}.sql"
              pg_dump "${{ steps.db-url.outputs.db_url }}" \
                --no-owner \
                --no-privileges \
                -f "$BACKUP_FILE"
              ;;
          esac

          # Compress with maximum compression
          echo "Compressing backup..."
          gzip -${{ env.COMPRESSION_LEVEL }} "$BACKUP_FILE"
          COMPRESSED_FILE="${BACKUP_FILE}.gz"

          # Generate checksum for integrity verification
          echo "Generating checksum..."
          CHECKSUM=$(sha256sum "$COMPRESSED_FILE" | cut -d' ' -f1)
          echo "$CHECKSUM  $COMPRESSED_FILE" > "${COMPRESSED_FILE}.sha256"

          # Get file size
          BACKUP_SIZE=$(ls -lh "$COMPRESSED_FILE" | awk '{print $5}')

          # Output for subsequent steps
          echo "backup_file=$COMPRESSED_FILE" >> $GITHUB_OUTPUT
          echo "backup_size=$BACKUP_SIZE" >> $GITHUB_OUTPUT
          echo "checksum=$CHECKSUM" >> $GITHUB_OUTPUT
          echo "timestamp=$TIMESTAMP" >> $GITHUB_OUTPUT

          echo ""
          echo "=== Backup Summary ==="
          echo "File: $COMPRESSED_FILE"
          echo "Size: $BACKUP_SIZE"
          echo "Checksum: $CHECKSUM"
          echo "Backup completed successfully"

      # ================================================================
      # UPLOAD TO GITHUB ARTIFACTS (Tier 1 Storage)
      # ================================================================
      - name: Upload to GitHub Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: database-backup-${{ steps.backup.outputs.timestamp }}
          path: |
            ${{ steps.backup.outputs.backup_file }}
            ${{ steps.backup.outputs.backup_file }}.sha256
          retention-days: ${{ env.BACKUP_RETENTION_DAYS }}

      # ================================================================
      # UPLOAD TO S3 (Tier 2 Storage - Optional)
      # ================================================================
      - name: Configure AWS Credentials
        if: github.event.inputs.upload_to_s3 != 'false' && secrets.AWS_ACCESS_KEY_ID != ''
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}

      - name: Upload to S3
        if: github.event.inputs.upload_to_s3 != 'false' && secrets.AWS_ACCESS_KEY_ID != ''
        run: |
          BUCKET="${{ secrets.BACKUP_BUCKET || 'flowbills-backups' }}"
          ENV="${{ github.event.inputs.environment || 'production' }}"

          echo "Uploading to S3..."
          aws s3 cp "${{ steps.backup.outputs.backup_file }}" \
            "s3://${BUCKET}/database/${ENV}/" \
            --storage-class STANDARD_IA

          aws s3 cp "${{ steps.backup.outputs.backup_file }}.sha256" \
            "s3://${BUCKET}/database/${ENV}/"

          echo "S3 upload complete: s3://${BUCKET}/database/${ENV}/"

      # ================================================================
      # BACKUP VERIFICATION
      # ================================================================
      - name: Verify Backup Integrity
        run: |
          echo "Verifying backup integrity..."

          # Verify checksum
          if sha256sum -c "${{ steps.backup.outputs.backup_file }}.sha256"; then
            echo "Checksum verification passed"
          else
            echo "::error::Checksum verification failed!"
            exit 1
          fi

          # Test decompression
          if gzip -t "${{ steps.backup.outputs.backup_file }}"; then
            echo "Compression integrity verified"
          else
            echo "::error::Backup file is corrupted!"
            exit 1
          fi

          echo "Backup verification complete"

  # ================================================================
  # NOTIFICATIONS JOB
  # ================================================================
  notify:
    runs-on: ubuntu-latest
    name: Send Notifications
    needs: database-backup
    if: always()

    steps:
      - name: Determine Status
        id: status
        run: |
          if [ "${{ needs.database-backup.result }}" = "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "emoji=white_check_mark" >> $GITHUB_OUTPUT
            echo "color=good" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "emoji=x" >> $GITHUB_OUTPUT
            echo "color=danger" >> $GITHUB_OUTPUT
          fi

      - name: Send Slack Notification
        if: secrets.SLACK_WEBHOOK_URL != ''
        continue-on-error: true
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          # Use literal heredoc to avoid interpolation issues
          PAYLOAD_TEMPLATE=$(cat <<'INNEREOF'
          {
            "attachments": [
              {
                "color": "__COLOR__",
                "blocks": [
                  {
                    "type": "header",
                    "text": {
                      "type": "plain_text",
                      "text": ":__EMOJI__: Database Backup __STATUS__",
                      "emoji": true
                    }
                  },
                  {
                    "type": "section",
                    "fields": [
                      {"type": "mrkdwn", "text": "*Environment:*\n__ENV__"},
                      {"type": "mrkdwn", "text": "*Size:*\n__SIZE__"},
                      {"type": "mrkdwn", "text": "*Checksum:*\n`__CHECKSUM__`"},
                      {"type": "mrkdwn", "text": "*Actor:*\n__ACTOR__"}
                    ]
                  },
                  {
                    "type": "context",
                    "elements": [
                      {"type": "mrkdwn", "text": "<__RUN_URL__|View Workflow Run>"}
                    ]
                  }
                ]
              }
            ]
          }
INNEREOF
          )

          # Use sed for safe variable replacement
          PAYLOAD=$(echo "$PAYLOAD_TEMPLATE" | \
            sed "s|__COLOR__|${{ steps.status.outputs.color }}|g" | \
            sed "s|__EMOJI__|${{ steps.status.outputs.emoji }}|g" | \
            sed "s|__STATUS__|${{ steps.status.outputs.status }}|g" | \
            sed "s|__ENV__|${{ github.event.inputs.environment || 'production' }}|g" | \
            sed "s|__SIZE__|${{ needs.database-backup.outputs.backup_size || 'N/A' }}|g" | \
            sed "s|__CHECKSUM__|${{ needs.database-backup.outputs.checksum || 'N/A' }}|g" | \
            sed "s|__ACTOR__|${{ github.actor }}|g" | \
            sed "s|__RUN_URL__|${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|g")

          # Retry logic (3 attempts)
          MAX_RETRIES=3
          RETRY_COUNT=0

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HTTP_CODE=$(curl -s -o /tmp/slack_response.txt -w "%{http_code}" \
              -X POST "$SLACK_WEBHOOK_URL" \
              -H "Content-Type: application/json" \
              -d "$PAYLOAD")

            if [ "$HTTP_CODE" = "200" ]; then
              echo "Slack notification sent successfully"
              exit 0
            fi

            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "Attempt $RETRY_COUNT failed (HTTP $HTTP_CODE), retrying..."
            sleep 2
          done

          echo "::warning::Slack notification failed after $MAX_RETRIES attempts"
          # Non-blocking exit
          exit 0

      - name: Send Discord Notification (Fallback)
        if: secrets.DISCORD_WEBHOOK_URL != '' && steps.status.outputs.status == 'failure'
        continue-on-error: true
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          PAYLOAD=$(cat <<'INNEREOF'
          {
            "content": ":x: **Database Backup Failed**",
            "embeds": [
              {
                "title": "Backup Failure Alert",
                "color": 16711680,
                "fields": [
                  {"name": "Repository", "value": "__REPO__", "inline": true},
                  {"name": "Actor", "value": "__ACTOR__", "inline": true}
                ],
                "footer": {"text": "FLOWBills Database Backup"}
              }
            ]
          }
INNEREOF
          )

          PAYLOAD=$(echo "$PAYLOAD" | \
            sed "s|__REPO__|${{ github.repository }}|g" | \
            sed "s|__ACTOR__|${{ github.actor }}|g")

          curl -s -X POST "$DISCORD_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD" || true

          echo "Discord fallback notification sent"

      - name: Generate Summary
        run: |
          echo "## Database Backup Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Status | ${{ steps.status.outputs.status }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | ${{ github.event.inputs.environment || 'production' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Backup Size | ${{ needs.database-backup.outputs.backup_size || 'N/A' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Checksum | \`${{ needs.database-backup.outputs.checksum || 'N/A' }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Triggered by | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
